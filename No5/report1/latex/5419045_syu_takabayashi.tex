\documentclass[dvipdfmx]{jsarticle}
\usepackage[T1]{fontenc}
\usepackage[dvipdfmx]{hyperref}
\usepackage{lmodern}
\usepackage{latexsym}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{here}
\usepackage{float}
\usepackage{ascmac}
\usepackage{url}

\title{Javaを用いたデザインパターンコーディングの必要性}
\author{文理学部情報科学科\\5419045 高林 秀}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
本稿では、今年度発展プログラミングの課題研究として「デザインパターン」に準拠したコーディングスタイルの必要性について、実際に自身でコーディングを行い、論ずる。本演習にはJavaを利用した。
\end{abstract}

\section{目的}
本稿は今年度発展プログラミングの課題研究として、「デザインパターン」に準拠したコーディングスタイルの必要性について論ずることを目的とする。本稿前半では、デザインパターンの利点・効果・必要性などについて説明し、後半では、実際にコーディングを行う。その際、デザインパターンを使用する前のコードとデザインパターンを使用した際のコードを比較・考察していく。
\section{事前知識}
本稿ではJavaを使用する。クラス定義の仕方や、インタフェースなどのJavaで登場する用語についての説明は省略する。これらの解説は以下のURLからレポート「interface、抽象クラスを利用した Java のペア・プログラミング」を参考いただきたい。
\begin{itemize}
  \item url:\url{https://drive.google.com/drive/folders/1QEt-NBptDGq2J1BgOyFnGUx8SMwL5oNc?usp=sharing}
\end{itemize}
\section{デザインパターンとはなにか}
この章では、プログラムコーディングおけるデザインパターンとはどのようなものなのか、歴史的背景や利点・効果、その必要性について述べる。\par
\subsection{歴史的背景}
デザインパターンは、オブジェクト指向型プログラミング言語において、記述したコードを様々なプログラムで再利用できるようにするために考案された「プログラムの設計ルール」のようなものである。1955年に出版された書籍「オブジェクト指向における再利用のためのデザインパターン\cite{book01}」にて、初めて「デザインパターン」と呼ばれる用語が使用された。その書籍の広がりにより、デザインパターンの考え方が広く知られるようになった。\par
その書籍の著者ら（※参考文献の原著4名）は、23種にもおよぶデザインパターンを取り上げており、デザインパターンとはなにか、以下のように述べている。以下、\url{https://ja.wikipedia.org/wiki/%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3_(%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2)}より引用する。
\begin{itemize}
  \item 原文
  \begin{quote}
    [Design patterns] solve specific design problems and make object-oriented designs more flexible, elegant, and ultimately reusable. They help designers reuse successful designs by basing new designs on prior experience. A designer who is familiar with such patterns can apply them immediately to design problems without having to rediscover them.
  \end{quote}
  \item 訳文(Deepl\footnote{ドイツに拠点を置くDeepL GmbHによって開発された、ニューラルネットワークによる翻訳を行うサービス。Google 翻訳よりも精度が高く、微妙なニュアンスのある翻訳ができると話題。}による翻訳)
  \begin{quote}
    特定の設計上の問題を解決し、オブジェクト指向設計をより柔軟に、エレガントに、そして最終的には再利用可能にします。デザインパターンは、新しいデザインを過去の経験に基づいて行うことで、成功したデザインを再利用するのに役立ちます。このようなパターンに精通している設計者は、パターンを再発見することなく、すぐに設計問題に適用することができます。
  \end{quote}
\end{itemize}
この書籍の著者たちは「Gof（Gang of Four）」と呼ばれデザインパターンの名前の１つにもなっている。\par
余談だが、Gofのデザインパターンはかなり前のデザインパターンである。そのため、現代では賛否両論あるようで、一部では批判的な意見も挙げられている。というのも、後に説明するが、デザインパターンはJavaやRubyなどオブジェクト指向型言語で使用される考え方だ。しかしGofのデザインパターンが発表されたのはJavaがリリースされる1995年よりも前、つまりオブジェクト指向プログラミングというものが未熟な時代に発表されたからだ。したがって、現代のプログラミングと合致しない場合もあるという。この意見は\url{https://qiita.com/irxground/items/d1f9cc447bafa8db2388}より参考にさせていただいた。
\subsection{デザインパターンの利点}
前述した通り、デザインパターンの主目的は「コードを様々なプログラムで再利用できるようにする」ことである。ただし、利用するデザインパターンにより、その効果は少し異なる。今回扱う、Gofのデザインパターンは大きく分けて、「生成」、「構造」,「振る舞い」の3つのカテゴリに分類され、その総数は後述するように計23パターンにおよぶ。\par
以上のように分類され、体系が出来上がった概念、考え方なので巷では初心者エンジニアが、オブジェクト指向を学習するときの題材として利用しやすいことも１つの利点と言えるだろう。\par
さて、デザインパターンの大きな利点として、先に上げた「コードの再利用」の他に以下の３つが挙げられるだろう。
\begin{itemize}
  \item 可読性の向上
  \item 保守性の向上
  \item 設計の短時間化
\end{itemize}
\paragraph{可読性の向上}まず、「可読性の向上」だがこれは自分が作成したプログラムを、他のエンジニアやプログラマーが閲覧するときに、そのプログラム、クラスがどんな役割を果たしているのか、どのような意図のコードなのかが把握しやすくなるという意味だ。先に示したように、デザインパターンはすでに確立されたプログラムの設計概念である。したがって、いわば共通言語のようなものであるので、デザインパターンを意識したプログラムは他人からも読みやすいということになる。\par
\paragraph{保守性の向上}次に、「保守性の向上」だがこれは、例えば呼び出し元プログラムの実装方法が変更になった場合でも呼び出し側のプログラムに修正を加えることなく実行できるということだ。大規模な開発になると、実装元と呼び出し側にコードを分散させることが多々あるが、仕様変更やアップデート等で実装側のコードを改変した場合、デザインパターンを意識しないで呼び出し側を設計すると、実装元と呼び出し側両方のプログラムを修正しなければならない。この様なプログラムは、実装側の修正箇所が多くなるたびに呼び出し側も修正しなければならないため非常に効率が悪い。加えて、実装側のコードや動作を把握しなければ呼び出し側の設計ができないという欠点も生じる。\par
デザインパターンを導入すれば、少ない修正でプログラムを動かすことが可能になる。
\paragraph{設計の短時間化}最後に「設計の短時間化」であるが、これはコードの再利用の点と一部重なるかもしれない。デザインパターンは、Gofのデザインパターンの著者を初め、すでに誰かが考え出した設計にしたがってプログラムの設計を行う。したがって、自身で保守性や再利用性を向上させようとあれこれ試行錯誤する必要はなく、コーディング作業全体の効率化を図ることができる。
\subsubsection{デザインパターンの必要性}
ここまで、デザインパターンの利点を述べてきたが、ここではデザインパターンの利用が推奨されるケースについて説明する。\par
現代でプログラミングをする際、すでにこの世に存在している機能をもう一度初めから開発する手間を省くため「ライブラリ」や「フレームワーク」と呼ばれるものが存在する。「ライブラリ」とは、すでに誰かが開発した機能や技術を、他人のプログラム内に組み込めるようにしたものである。有名どころをいくつか列挙すると、Pythonならば、プログラムからウェブブラウザを操作できる機能を提供する「selenium」や、数値計算を高速化、用意にする「numpy」,「pandas」などがあるだろう。Javaならば、webサーバーを構築する際に使用される「Apache HTTP Server」や、HTMLを解析する際に使用される「Jsoup」など多種多様なものが存在する。\par
これらのライブラリやフレームワークが提供する機能を、指定されるコードを用いて、自身の目的に合わせて作成するプログラムに組み込むことができる。\par
つまり、ライブラリやフレームワークを利用するときは、あらかじめ用意されているプログラムを再利用することになる。また、ライブラリやフレームワークが提供する関数やメソッドの処理内容は原則変更することができない。\par
例えば外部に公開されているライブラリを利用し、自身のプログラムを記述する場面を考える。ライブラリから提供される関数やメソッドを呼び出しているのが原因で、自身の意図する目的と異なる動作をすることがある。しかし、ライブラリ側のコードを自身で書き換えると利用している他の関数やメソッドの動作に影響するため、安易に改変することはできない、とする。この様な場合、ライブラリ側のプログラムと、自身で作成したプログラムの動作の差異を吸収するプログラムが必要になってくる。この様な場合は、後述する「Adapterパターン」と呼ばれるデザインパターンを利用することで解決できる場合がある。\par
当然、上で示した各利点を目的とする場合は、それそれのケースに適したデザインパターンを利用することが推奨される。
\subsection{デザインパターンの種類}
先に示したように、デザインパターンは合計23種類ものパターンが存在する。まず「生成」、「構造」,「振る舞い」の3つのカテゴリそれぞれに該当するデザインパターンについて軽く説明を行う。なお、最後に本稿の演習で使用するデザインパターンであるBridgeパターンについて詳細に取り上げる。
\subsubsection{オブジェクト生成に関するパターン}
オブジェクトの生成を以下のパターンによってコントロールすることができる。状況に応じてオブジェクトの生成をコントロールすることにより、アプリケーション全体の設計に悪影響を与えることを防ぐことができる。以下は、生成に関するパターンに属するデザインパターンである。
\begin{itemize}
  \item Abstract Factory
  \item Builder
  \item Factory Method
  \item Prototype
  \item Singleton
\end{itemize}
\subsubsection{プログラム構造に関するパターン}
オブジェクト同士の関係性を用意にする設計を提供するデザインパターンである。以下のものが構造に関するデザインパターンに該当する。
\begin{itemize}
  \item Adapter
  \begin{itemize}
    \item 本来関係のないクラス同士を関連付けることができるデザインパターンである。先に示したように、提供されているコードと、作成コードの差異を埋めるようなデザインパターンである。
  \end{itemize}
  \item Bridge
  \begin{itemize}
    \item 親クラスに抽象メソッドが定義されている場合、そのメソッドの実装と、実装とは関係ない新機能の記載を分けるようなデザインパターンである。これに関しては、本演習で使用するので、後ほど改めて説明する。
  \end{itemize}
  \item Composite
    \begin{itemize}
      \item 日本語では「複合物」を意味する。全体を囲む「容器」とその「中身」を同じものとして捉え、共通機能を持たせる際に利用する（ファイルシステムなど）。オブジェクトの再帰的な取扱を容易にすることができる。より、具体的にいうと、オブジェクトの集合（グループ）を、オブジェクトの１つのインスタンスとして取り扱うことである。
    \end{itemize}
  \item Decorator
  \begin{itemize}
    \item 同じ様な機能の追加を行うとき、クラスの継承以外の手法で既存のクラスを拡張する際に用いられる。
  \end{itemize}
  \item Facade
  \begin{itemize}
    \item 既存のクラスを複数組み合わせて使うような処理があるとき、複雑さを回避するため、それらのクラスの「窓口や受付」の役割を果たすようなクラスを作成することで構造をシンプルにしようとするデザインパターンである。
  \end{itemize}
  \item Flyweight
  \begin{itemize}
    \item このデザインパターンは計算機のリソース利用の効率化に焦点をあてたデザインパターンである。具体的には、同一のインスタンスを共有したりすることで、無駄なインスタンスの生成を防ぐことができ、プログラムのメモリ使用量などを軽くすることができる。
  \end{itemize}
  \item Proxy
  \begin{itemize}
    \item 日本語では「代理人」を意味する。Proxyパターンは、元のオブジェクトの処理を、別のオブジェクトが肩代わりするようなデザインパターンである。元オブジェクトが行う必要がない処理を代理する別オブジェクトを作成することで、処理の効率化を図ることができる。
  \end{itemize}
\end{itemize}
\subsubsection{オブジェクトの振る舞いに関するパターン}
オブジェクト間の通信を容易に行えるようにするデザインパターンである。例えば、異なるクラスでデータのやり取りを行いたい場合などが該当する。以下のものが振る舞いに関するデザインパターンに該当する。
\begin{itemize}
  \item Chain of Responsibility
  \item Command
  \item Interpreter
  \item Iterator
  \item Mediator
  \item Memento
  \item Observer
  \item State
  \item Strategy
  \item Template Method
  \item Visitor
\end{itemize}



\section{実際のコーディングでデザインパターンを利用する}
\subsection{課題説明}
\paragraph{問題} 任意のデザインパターンを1つ選択し、そのパターンを用いる前と用いた後のコード両方を作成して示し、そのパターンを用いたことの効果を説明せよ。
\begin{itemize}
  \item 選択したデザインパターン：Bridgeパターン
\end{itemize}

\subsubsection{演習環境}
今回の演習は仮想マシン上でJavaを使用し行った。下記に演習時の環境を示す。
\begin{itemize}
  \item ホストOS：Window10 Home 20H2
  \item 仮想OS：Ubuntu 20.04.2 LTS
  \item CPU：Intel(R)Core(TM)i7-9700K @ 3.6GHz
  \item GPU：Nvidia Geforce RTX2070 OC @ 8GB
  \item ホストRAM：16GB
  \item 仮想RAM：4GB
  \item 使用言語：Java
  \begin{itemize}
    \item バージョン情報は下記に示す。
    \begin{verbatim}
      openjdk version "11.0.11" 2021-04-20
      OpenJDK Runtime Environment (build 11.0.11+9-Ubuntu-0ubuntu2.20.04)
      OpenJDK 64-Bit Server VM (build 11.0.11+9-Ubuntu-0ubuntu2.20.04, mixed mode, sharing)
    \end{verbatim}
  \end{itemize}
\end{itemize}

\subsection{制作物}
\subsubsection{デザインパターン前のソースコード}
\subsubsection{デザインパターン後のソースコード}
\subsection{考察}
\section{まとめ}
\section{巻末資料}
\begin{thebibliography}{99}
  \bibitem{book01}  Erich Gamma (原著), Ralph Johnson (原著), Richard Helm (原著), John Vlissides (原著), 本位田 真一 (翻訳), 吉田 和樹 (翻訳)「オブジェクト指向における再利用のためのデザインパターン」改訂版（ソフトバンククリエイティブ,1999/10/1)
\end{thebibliography}

\end{document}
